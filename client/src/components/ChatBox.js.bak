import React, { useEffect, useState, useRef, useCallback } from 'react';
import { useSocket } from '../contexts/SocketContext';
import { useAuth } from '../contexts/AuthContext';
import api from '../services/api';
    e.preventDefault();
    
    if (!inputMessage.trim() || sending) return;
    
    const messageText = inputMessage.trim();
    const tempMessage = {
      message: messageText,
      userId: user.id,
      userName: user.display_name || user.username,
      timestamp: new Date().toISOString(),
      tempId: `${user.id}-${Date.now()}`,
      saved: false
    };
    
    // ë¨¼ì € ë©”ì‹œì§€ë¥¼ ë¡œì»¬ì— ì¶”ê°€
    setMessages(prev => [...prev, tempMessage]);
    setInputMessage('');
    setSending(true);
    requestAnimationFrame(scrollToBottom);
    
    // ì…ë ¥ í•„ë“œì— í¬ì»¤ìŠ¤ ìœ ì§€
    inputRef.current?.focus();rvices/api';
import '../styles/ChatBox.css';

function ChatBox({ roomId }) {
  const [messages, setMessages] = useState([]);
  const [inputMessage, setInputMessage] = useState('');
  const [typingUsers, setTypingUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [sending, setSending] = useState(false);
  const [hasMore, setHasMore] = useState(false);
  const messagesEndRef = useRef(null);
  const messagesContainerRef = useRef(null);
  const typingTimeoutRef = useRef(null);
  const inputRef = useRef(null);
  const processedMessages = useRef(new Set());
  
  const { socket, sendMessage, startTyping, stopTyping } = useSocket();
  const { user } = useAuth();
  
  const scrollToBottom = useCallback(() => {
    requestAnimationFrame(() => {
      messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    });
  }, []);

  const isNearBottom = useCallback(() => {
    if (!messagesContainerRef.current) return true;
    const { scrollTop, scrollHeight, clientHeight } = messagesContainerRef.current;
    return scrollHeight - scrollTop - clientHeight < 100;
  }, []);

  // ì±„íŒ… ê¸°ë¡ ë¡œë“œ í•¨ìˆ˜
  const loadChatHistory = useCallback(async () => {
    if (!roomId) return;
    
    try {
      setLoading(true);
      console.log('ğŸ“š Loading chat history for room:', roomId);
      
      const response = await api.get(`/chat/room/${roomId}`, {
        params: { limit: 50 }
      });
      
      if (response.success) {
        console.log(`âœ… Loaded ${response.messages.length} messages`);
        setMessages(response.messages);
        setHasMore(response.hasMore);
        requestAnimationFrame(scrollToBottom);
      }
    } catch (error) {
      console.error('Failed to load chat history:', error);
    } finally {
      setLoading(false);
    }
  }, [roomId, scrollToBottom]);

  // ì»´í¬ë„ŒíŠ¸ ë§ˆìš´íŠ¸ ì‹œ ì±„íŒ… ê¸°ë¡ ë¡œë“œ
  useEffect(() => {
    loadChatHistory();
  }, [loadChatHistory]);

  // Socket ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
  useEffect(() => {
    if (!socket) return;

    // ìƒˆ ë©”ì‹œì§€ ìˆ˜ì‹ 
    const handleNewMessage = (message) => {
      console.log('ğŸ“¨ New message received:', message);
      
      // ì¤‘ë³µ ë°©ì§€: ì´ë¯¸ ì²˜ë¦¬í•œ ë©”ì‹œì§€ì¸ì§€ í™•ì¸
      const messageKey = message.id || 
        (message.timestamp && `${message.userId}-${message.timestamp}-${message.message}`);
      
      if (messageKey && processedMessages.current.has(messageKey)) {
        console.log('âš ï¸ Duplicate message detected, skipping');
        return;
      }

      // ë©”ì‹œì§€ í‚¤ë¥¼ ì²˜ë¦¬ëœ ëª©ë¡ì— ì¶”ê°€
      if (messageKey) {
        processedMessages.current.add(messageKey);
      }
      
      setMessages(prev => {
        // ì´ë¯¸ ê°™ì€ ë©”ì‹œì§€ê°€ ìˆëŠ”ì§€ í•œ ë²ˆ ë” í™•ì¸
        const isDuplicate = prev.some(m => 
          (m.id && m.id === message.id) || 
          (m.tempId && m.tempId === message.tempId)
        );
        
        if (isDuplicate) {
          console.log('âš ï¸ Duplicate message detected in state, skipping');
          return prev;
        }

        // ë©”ì‹œì§€ë¥¼ ì¦‰ì‹œ ì¶”ê°€í•˜ê³  ìŠ¤í¬ë¡¤
        const newMessages = [...prev, message];
        
        // ë‹¤ìŒ í‹±ì—ì„œ ìŠ¤í¬ë¡¤ ì‹¤í–‰
        if (message.userId === user?.id || isNearBottom()) {
          requestAnimationFrame(scrollToBottom);
        }
        
        return newMessages;
      });
    };

    // íƒ€ì´í•‘ ìƒíƒœ ìˆ˜ì‹ 
    const handleUserTyping = (data) => {
      setTypingUsers(prev => {
        if (!prev.find(u => u.userId === data.userId)) {
          return [...prev, data];
        }
        return prev;
      });
    };

    const handleUserStoppedTyping = (data) => {
      setTypingUsers(prev => prev.filter(u => u.userId !== data.userId));
    };

    socket.on('new_message', handleNewMessage);
    socket.on('user_typing', handleUserTyping);
    socket.on('user_stopped_typing', handleUserStoppedTyping);

    return () => {
      socket.off('new_message', handleNewMessage);
      socket.off('user_typing', handleUserTyping);
      socket.off('user_stopped_typing', handleUserStoppedTyping);
    };
  }, [socket, user, isNearBottom, scrollToBottom]);

  // ì´ì „ ë©”ì‹œì§€ ë” ë¶ˆëŸ¬ì˜¤ê¸°
  const loadMoreMessages = async () => {
    if (!hasMore || loading || messages.length === 0) return;
    
    try {
      const oldestMessage = messages[0];
      console.log('ğŸ“š Loading more messages before:', oldestMessage.created_at);
      
      const response = await api.get(`/chat/room/${roomId}`, {
        params: { 
          limit: 30,
          before: oldestMessage.created_at
        }
      });
      
      if (response.success) {
        setMessages(prev => [...response.messages, ...prev]);
        setHasMore(response.hasMore);
      }
    } catch (error) {
      console.error('Failed to load more messages:', error);
    }
  };

  // ìŠ¤í¬ë¡¤ ê´€ë ¨ í•¨ìˆ˜ë“¤ì€ ìƒë‹¨ì—ì„œ ì´ë¯¸ ì •ì˜ë˜ì—ˆìœ¼ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” ì œê±°

  const handleInputChange = (e) => {
    setInputMessage(e.target.value);
    
    // íƒ€ì´í•‘ ì‹œì‘ ì•Œë¦¼
    if (e.target.value && !typingTimeoutRef.current) {
      startTyping(roomId);
    }
    
    // ê¸°ì¡´ íƒ€ì„ì•„ì›ƒ ì·¨ì†Œ
    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }
    
    // 2ì´ˆ í›„ íƒ€ì´í•‘ ì¤‘ì§€
    typingTimeoutRef.current = setTimeout(() => {
      stopTyping(roomId);
      typingTimeoutRef.current = null;
    }, 2000);
  };

  const handleSendMessage = async (e) => {
    e.preventDefault();
    
    if (!inputMessage.trim() || sending) return;
    
    const messageText = inputMessage.trim();
    const tempMessage = {
      message: messageText,
      userId: user.id,
      userName: user.display_name || user.username,
      timestamp: new Date().toISOString(),
      tempId: `${user.id}-${Date.now()}`,
      saved: false
    };
    
    // ë¨¼ì € ë©”ì‹œì§€ë¥¼ ë¡œì»¬ì— ì¶”ê°€
    setMessages(prev => [...prev, tempMessage]);
    setInputMessage('');
    setSending(true);
    scrollToBottom();
    
    // íƒ€ì´í•‘ ì¤‘ì§€
    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
      typingTimeoutRef.current = null;
      stopTyping(roomId);
    }
    
    try {
      console.log('ğŸ“¤ Sending message via socket');
      await sendMessage(roomId, messageText);
    } catch (error) {
      console.error('Failed to send message:', error);
      
      // ì—ëŸ¬ ë°œìƒ ì‹œ ì„ì‹œ ë©”ì‹œì§€ ì œê±°
      setMessages(prev => prev.filter(m => m.tempId !== tempMessage.tempId));
      alert('ë©”ì‹œì§€ ì „ì†¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
    } finally {
      setSending(false);
    }
  };

  const handleScroll = (e) => {
    // ìŠ¤í¬ë¡¤ì´ ë§¨ ìœ„ì— ë„ë‹¬í–ˆì„ ë•Œ ì´ì „ ë©”ì‹œì§€ ë¡œë“œ
    if (e.target.scrollTop === 0 && hasMore && !loading) {
      loadMoreMessages();
    }
  };

  // ë©”ì‹œì§€ ì‹œê°„ í¬ë§·
  const formatTime = (timestamp) => {
    const date = new Date(timestamp);
    const now = new Date();
    const isToday = date.toDateString() === now.toDateString();
    
    if (isToday) {
      return date.toLocaleTimeString('ko-KR', { 
        hour: '2-digit', 
        minute: '2-digit' 
      });
    } else {
      return date.toLocaleDateString('ko-KR', { 
        month: 'short', 
        day: 'numeric',
        hour: '2-digit', 
        minute: '2-digit' 
      });
    }
  };

  // ë‚ ì§œ êµ¬ë¶„ì„  í‘œì‹œ ì—¬ë¶€
  const shouldShowDateDivider = (currentMsg, prevMsg) => {
    if (!prevMsg) return true;
    
    const currentDate = new Date(currentMsg.created_at || currentMsg.timestamp);
    const prevDate = new Date(prevMsg.created_at || prevMsg.timestamp);
    
    return currentDate.toDateString() !== prevDate.toDateString();
  };

  if (loading && messages.length === 0) {
    return (
      <div className="chat-container">
        <div className="chat-loading">
          ì±„íŒ…ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...
        </div>
      </div>
    );
  }

  return (
    <div className="chat-container">
      <div 
        className="messages-container" 
        ref={messagesContainerRef}
        onScroll={handleScroll}
      >
        {hasMore && (
          <div className="load-more">
            <button onClick={loadMoreMessages} disabled={loading}>
              ì´ì „ ë©”ì‹œì§€ ë³´ê¸°
            </button>
          </div>
        )}
        
        {messages.map((msg, index) => {
          // ë©”ì‹œì§€ì˜ ê³ ìœ  í‚¤ ìƒì„±
          const messageKey = msg.id || msg.tempId || `${msg.userId}-${msg.timestamp}-${index}`;
          
          return (
            <React.Fragment key={messageKey}>
              {shouldShowDateDivider(msg, messages[index - 1]) && (
                <div className="date-divider">
                  <span>
                    {new Date(msg.created_at || msg.timestamp).toLocaleDateString('ko-KR', {
                      year: 'numeric',
                      month: 'long',
                      day: 'numeric'
                    })}
                  </span>
                </div>
              )}
              
              <div 
                className={`message ${msg.userId === user?.id || msg.user_id === user?.id ? 'own-message' : ''}`}
              >
                <div className="message-header">
                  <span className="message-user">
                    {msg.userName || msg.users?.display_name || msg.users?.username}
                  </span>
                  <span className="message-time">
                    {formatTime(msg.created_at || msg.timestamp)}
                  </span>
                  {msg.saved === false && (
                    <span className="message-status" title="ì €ì¥ë˜ì§€ ì•ŠìŒ">âš ï¸</span>
                  )}
                </div>
                <div className="message-text">{msg.message}</div>
              </div>
            </React.Fragment>
          );
        })}
        
        {typingUsers.length > 0 && (
          <div className="typing-indicator">
            {typingUsers.map(u => u.userName).join(', ')} 
            {typingUsers.length === 1 ? 'ë‹˜ì´' : 'ë‹˜ë“¤ì´'} ì…ë ¥ ì¤‘...
          </div>
        )}
        
        <div ref={messagesEndRef} />
      </div>
      
      <form className="chat-input-form" onSubmit={handleSendMessage}>
        <input
          ref={inputRef}
          type="text"
          className="chat-input"
          placeholder="ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš”..."
          value={inputMessage}
          onChange={handleInputChange}
          disabled={sending}
        />
        <button 
          type="submit" 
          className="send-button"
          disabled={!inputMessage.trim() || sending}
        >
          ì „ì†¡
        </button>
      </form>
    </div>
  );
}

export default ChatBox;